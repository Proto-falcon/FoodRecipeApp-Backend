{"version":3,"sources":["src/components/RecipeList/RecipeList.js"],"names":["RecipeList","props","useState","recipes","setRecipes","isMoreRecipes","setIsMoreRecipes","loadedAllRecipes","setLoadedAllRecipes","distanceFromEnd","showEnd","undefined","setData","recipeLink","response","axios","method","url","BACKEND","responseType","content","data","results","addRecipesLink","error","length","id","prevState","newState","push","name","image","ingredients","source","useEffect","style","flex","width","alignItems","numColumns","Math","round","useWindowDimensions","renderItem","item","height","onEndReached","onEndReachedThreshold","extraData"],"mappings":"0PA6Be,SAASA,EAAWC,GAClC,MAA8BC,mBAASD,EAAME,SAAQ,WAA9CA,EAAO,KAAEC,EAAU,KAC1B,EAA0CF,oBAAS,GAAK,WAAjDG,EAAa,KAAEC,EAAgB,KACtC,EAAgDJ,oBAAS,GAAM,WAAxDK,EAAgB,KAAEC,EAAmB,KAgBd,aAuC7B,OAvC6B,OAA9B,aAAgD,EAAfC,gBAChC,GAAIR,EAAMS,cAA6BC,IAAlBV,EAAMW,QAC1B,QACqBD,GAApBV,EAAMY,YACc,IAApBZ,EAAMY,YACNR,EAEA,IACC,IAAIS,QAAiBC,kBAAM,CAC1BC,OAAQ,MACRC,IAAQC,UAAO,6BAA6BjB,EAAMY,WAClDM,aAAc,SAGXC,QAAgBN,EAASO,KAC7BpB,EAAMW,QAAQQ,EAAQE,QAASF,EAAQG,gBACtC,MAAOC,GACRlB,GAAiB,OAGgB,IAAlCH,EAAQA,EAAQsB,OAAS,GAAGC,KAC3BnB,GACDN,EAAMS,UAENN,GAAW,SAACuB,GACX,IAAIC,EAAQ,IAAOD,GASnB,OARAC,EAASC,KAAK,CACbH,GAAI,GACJI,KAAM,kBACNC,MAAO,GACPC,YAAa,GACbC,OAAQ,KAGFL,KAERpB,GAAoB,SAACmB,GAAS,OAAMA,UAGtC,sBAjDDO,qBAAU,WACT9B,EAAWH,EAAME,WACf,CAACF,EAAME,UA6EV,OACC,cAAC,UAAI,CAACgC,MAPS,CACfC,KAAM,EACNC,MAAO,OACPC,WAAY,UAIW,SACtB,cAAC,UAAQ,CACRC,WAAYC,KAAKC,MAAMC,oBAAsBL,MAAQ,KACrDhB,KAAMlB,EACNwC,WAAY,gBAAGC,EAAI,EAAJA,KAAI,OAClB,cAAC,UAAW,CACXC,OAAQ,IACRR,MAAO,IACPO,KAAMA,KAGRE,aAzFiB,SAQW,GAAD,gCAkF3BC,sBAAuB,EACvBC,UAAW7C","file":"static/js/7.f6bffc38.chunk.js","sourcesContent":["import axios from \"axios\";\r\nimport { useEffect, useState } from \"react\";\r\nimport {\r\n\tFlatList,\r\n\tuseWindowDimensions,\r\n\tView,\r\n} from \"react-native\";\r\nimport BACKEND from \"../../ipaddressesports/BackEndIP\";\r\nimport RecipeCover from \"../RecipeCover/RecipeCover\";\r\n\r\n/**\r\n * Renders a list of Recipes\r\n * @typedef {{\r\n *  \tid: string,\r\n * \t\tname: string,\r\n *  \timage: any,\r\n *  \tingredients: Array<string>,\r\n * \t\tsource: string\r\n * \t}} recipe\r\n *\r\n * @param {{\r\n * \trecipes: Array<recipe>,\r\n *  recipeLink?: string,\r\n *  setData?: (recipeResults: Array<recipe>, addRecipesLink: string) => void,\r\n * \tshowEnd: boolean,\r\n * \tnavigation: any\r\n * }} props\r\n * @returns List of Recipes\r\n */\r\nexport default function RecipeList(props) {\r\n\tconst [recipes, setRecipes] = useState(props.recipes); // List of recipes\r\n\tconst [isMoreRecipes, setIsMoreRecipes] = useState(true);\r\n\tconst [loadedAllRecipes, setLoadedAllRecipes] = useState(false);\r\n\r\n\t/**\r\n\t * Forces it to update the list because some reason\r\n\t * it doens't register it on first render\r\n\t */\r\n\tuseEffect(() => {\r\n\t\tsetRecipes(props.recipes);\r\n\t}, [props.recipes]);\r\n\r\n\t/**\r\n\t * Adds more recipes to the current list\r\n\t * when the user scrolls near the bottom\r\n\t *\r\n\t * @param {{distanceFromEnd: number}?} info\r\n\t */\r\n\tasync function loadMoreRecipes({ distanceFromEnd }) {\r\n\t\tif (props.showEnd || props.setData !== undefined) {\r\n\t\t\tif (\r\n\t\t\t\tprops.recipeLink != undefined &&\r\n\t\t\t\tprops.recipeLink != \"\" &&\r\n\t\t\t\tisMoreRecipes\r\n\t\t\t) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tlet response = await axios({\r\n\t\t\t\t\t\tmethod: \"get\",\r\n\t\t\t\t\t\turl: `${BACKEND}/api/addRecipes/?nextLink=${props.recipeLink}`,\r\n\t\t\t\t\t\tresponseType: \"json\",\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\tlet content = await response.data;\r\n\t\t\t\t\tprops.setData(content.results, content.addRecipesLink);\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tsetIsMoreRecipes(false);\r\n\t\t\t\t}\r\n\t\t\t} else if (\r\n\t\t\t\trecipes[recipes.length - 1].id != \"\" &&\r\n\t\t\t\t!loadedAllRecipes &&\r\n\t\t\t\tprops.showEnd\r\n\t\t\t) {\r\n\t\t\t\tsetRecipes((prevState) => {\r\n\t\t\t\t\tlet newState = [...prevState];\r\n\t\t\t\t\tnewState.push({\r\n\t\t\t\t\t\tid: \"\",\r\n\t\t\t\t\t\tname: \"No more Recipes\",\r\n\t\t\t\t\t\timage: \"\",\r\n\t\t\t\t\t\tingredients: [],\r\n\t\t\t\t\t\tsource: \"\",\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\treturn newState;\r\n\t\t\t\t});\r\n\t\t\t\tsetLoadedAllRecipes((prevState) => !prevState);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the scroll view is near the bottom or not\r\n\t *\r\n\t * @param {{\r\n\t * \t\tlayoutMeasurement: {width: number, height: number},\r\n\t * \t\tcontentOffset: {x: number, y: number},\r\n\t * \t\tcontentSize: {width: number, height: number}\r\n\t * }} event\r\n\t * @returns `true` for near the bottom, `false` otherwise\r\n\t */\r\n\tfunction isCloseToBottom({\r\n\t\tlayoutMeasurement,\r\n\t\tcontentOffset,\r\n\t\tcontentSize,\r\n\t}) {\r\n\t\tconst paddingToBottom = contentSize.height * 0.2;\r\n\t\treturn (\r\n\t\t\tlayoutMeasurement.height + contentOffset.y >=\r\n\t\t\tcontentSize.height - paddingToBottom\r\n\t\t);\r\n\t}\r\n\r\n\tlet listStyle = {\r\n\t\tflex: 1,\r\n\t\twidth: \"100%\",\r\n\t\talignItems: \"center\"\r\n\t};\r\n\r\n\treturn (\r\n\t\t<View style={listStyle}>\r\n\t\t\t<FlatList\r\n\t\t\t\tnumColumns={Math.round(useWindowDimensions().width / 300)}\r\n\t\t\t\tdata={recipes}\r\n\t\t\t\trenderItem={({ item }) => (\r\n\t\t\t\t\t<RecipeCover\r\n\t\t\t\t\t\theight={300}\r\n\t\t\t\t\t\twidth={300}\r\n\t\t\t\t\t\titem={item}\r\n\t\t\t\t\t/>\r\n\t\t\t\t)}\r\n\t\t\t\tonEndReached={loadMoreRecipes}\r\n\t\t\t\tonEndReachedThreshold={2}\r\n\t\t\t\textraData={recipes}\r\n\t\t\t/>\r\n\t\t</View>\r\n\t);\r\n}\r\n"],"sourceRoot":""}